
public class Non {
	public static void main(String[] args) {
		System.out.println( ~-1 );

		假设这是个八位的机器

		正数的原码, 反码, 补码相同;

		0
		原码: 0000-0000
		反码: 1111-1111
		补码: 0000-0000 <= 1111-1111 0000-0000 八位机器, 截取最低八位

		1
		原码: 0000-0001
		反码: 0000-0001
		补码: 0000-0001

		-1
		原码: 1111-1111
		反码: 1111-1110
		补码: 1111-1111

		6
		原码: 0000-0110
		反码: 0000-0110
		补码: 0000-0110

		-6
		原码: 1111-1110
		反码: 1111-1001
		补码: 1111-1010

		~0
		原码: 0000-0000
		反码: 1111-1111
		补码: 0000-0000

		位非: 1111-1111
		// 将补码进行位非操作后, 其实结果也是补码的形式, 所以将位非后的二进制数转换为原码, 方法和补码一样: 减一, 再取反.
		减一: 1111-1110
		取反: 1000-0001	原码
		// 由于这个原码是负数, 因为其符号位是1啊, 所以将其转换为补码
		反码: 1111-1110
		补码: 1111-1111

		~0 = 1111-1111 = -1
		// 所以在计算器中 -1 的二进制数是 1111-1111, 就是这个原因.

		~1
		原码: 0000-0001
		反码: 0000-0001
		补码: 0000-0001

		位非: 1111-1110

		// 减一: 1111-1101 借一当二
		// 取反: 1000-0010 原码
		
		// 反码: 1111-1101
		// 补码: 1111-1110

		~1 = 1111-1110 = -2

		~-1
		原码: 1111-1111
		反码: 1111-1110
		补码: 1111-1111

		位非: 0000-0000

		// 减一: 1111-1111 借一当二
		// 取反: 1000-0000 原码
		
		// 反码: 1111-1111
		// 补码: 0000-0000

		~-1 = 0000-0000 = 0

		~6
		原码: 0000-0110
		反码: 0000-0110
		补码: 0000-0110

		位非: 1111-1001

		// 减一: 1111-1000
		// 取反: 1000-0111 原码
		
		// 反码: 1111-1000
		// 补码: 1111-1001

		~6 = 1111-1001 = -7

		~-6
		原码: 1000-0110
		反码: 1111-1001
		补码: 1111-1010

		位非: 0000-0101
		// 由与位非的数是负数, 所以到补码这就行了. 
		// 这跟 "将补码进行位非操作后, 其实结果也是补码的形式, 所以将位非后的二进制数转换为原码, 方法和补码一样: 减一, 再取反." 这句话是相对应的.
		// 就是因为位非的数是这个数的二进制补码表示形式, 又因为负数的在计算机中的表示形式是补码方式, 所以位非的数如果是负数, 直接进行位非操作, 不用进行转换为原码了.
		// 
		// 你可能会问了, 那正数的原码, 反码, 补码不是一样的吗, 为什么还要将补码转换为原码? (写~7时的问题....)
		// 嗯, 对啊....你看看上面, 位非正数的二进制数和位非后转为原码再转为补码的二进制数是一样的......
		// 
		// 还有个问题, 那么上面那个~-1怎么位非后和转为补码的结果一样?
		// 比如现在这个~-6, 继续操作: 
		// 减一: 0000-0100
		// 取反: 1111-1011
		// 反码: 1000-0100
		// 补码: 1000-0101
		// 这就成了-5的二进制原码了, 而答案是+5.
		// 因为~-1的结果是0, 所以无正负之分. 又因为补码是用来解决正0负0和正负数相加(相同的两个数)不等于0的问题, 但是这里用不到补码, 因为其位非后的结果全是0, 无负数符号位.
		// 
		// 总而言之, 位非运算后的二进制数(位非是操作补码的数, 又因为正数不区分原码反码补码, 所以只针对负数), 就是其结果, 若位非后的二进制数带有负数符号位的, 就表示这个结果是个负数, 
		// 总而言之, 负数的位非运算(~), 位非补码后的二进制数就是其结果, 因为什么? 因为负数在二进制中是以补码的形式存在的, 将一个补码进行一个操作后, 得到的还是补码, 所以不需要转换为其他形式. 就好比把一辆车拿去改装, 改装回来的还是那辆车.
		// 

		~-6 = 0000-0101 = 5

		~-4
		原码: 1000-0100
		反码: 1111-1011
		补码: 1111-1100

		位非: 0000-0011

		~-4 = 0000-0011 = 3

		~7
		原码: 0000-0111
		反码: 0000-0111
		补码: 0000-0111

		位非: 1111-1000

		// 减一: 1111-0111
		// 取反: 1000-1000 原码

		// 反码: 1111-0111
		// 补码: 1111-1000

		~7 = 1111-1000 = -8

		~-7
		原码: 1000-0111
		反码: 1111-1000
		补码: 1111-1001

		位非: 0000-0110

		~-7 = 0000-0101 = 6

	}
}