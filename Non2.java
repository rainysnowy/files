
public class Non2 {
	public static void main(String[] args) {
		System.out.println( ~-1 );

		假设这是个八位的机器

		正数的原码, 反码, 补码相同;

		0
		原码: 0000-0000
		反码: 1111-1111
		补码: 0000-0000 <= 1111-1111 0000-0000 八位机器, 截取最低八位

		1
		原码: 0000-0001
		反码: 0000-0001
		补码: 0000-0001

		-1
		原码: 1111-1111
		反码: 1111-1110
		补码: 1111-1111

		6
		原码: 0000-0110
		反码: 0000-0110
		补码: 0000-0110

		-6
		原码: 1111-1110
		反码: 1111-1001
		补码: 1111-1010

		~0
		原码: 0000-0000
		反码: 1111-1111
		补码: 0000-0000
		位非: 1111-1111

		~0 = 1111-1111 = -1

		~1
		原码: 0000-0001
		反码: 0000-0001
		补码: 0000-0001
		位非: 1111-1110

		~1 = 1111-1110 = -2

		~-1
		原码: 1111-1111
		反码: 1111-1110
		补码: 1111-1111
		位非: 0000-0000

		~-1 = 0000-0000 = 0

		~6
		原码: 0000-0110
		反码: 0000-0110
		补码: 0000-0110
		位非: 1111-1001

		~6 = 1111-1001 = -7

		~-6
		原码: 1000-0110
		反码: 1111-1001
		补码: 1111-1010
		位非: 0000-0101

		~-6 = 0000-0101 = 5

		~-4
		原码: 1000-0100
		反码: 1111-1011
		补码: 1111-1100
		位非: 0000-0011

		~-4 = 0000-0011 = 3

		~7
		原码: 0000-0111
		反码: 0000-0111
		补码: 0000-0111
		位非: 1111-1000

		~7 = 1111-1000 = -8

		~-7
		原码: 1000-0111
		反码: 1111-1000
		补码: 1111-1001
		位非: 0000-0110

		~-7 = 0000-0101 = 6

		// 位非后的二进制数就是其结果, 不管位非的是正数还是负数. 
		// 如果是正数, 那么它的二进制数, 不管是补码, 原码还是反码都是一样的. 如果是负数, 由于位非后的二进制数刚好是补码的形式, 而负数在计算机中是以补码的形式存在的, 所以刚刚好.
		// 为什么位非后的二进制数是补码? 其实也不是真的补码, 只是把原补码的二进制进行位运算了一下. 就好比, 把一辆车拿去改造, 改造后的车还是原来那辆车. 当然我这里说的不对, 如果理解不了, 直接放弃我这段话.
		// 
		// 第二种解释: 由于像这种位运算符, 仅是运算一次. 像位与(&), 位或(|), 异或(^), 左移(<<), 右移(>>), 无符号右移(>>>)这些位运算都只运算一次. 只运算一次是什么意思? 就是一个位运算符运算完之后可以直接返回结果. 

	}
}