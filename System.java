
/**
 * 进制转换
 *
 * @author c
 * @date 2018-1-16
 */
public class System {

	/**
	 * “原码、反码、补码的由来”
	 * 
	 * Okay，我们先来用二进制数表示十进制中的 0 ~ 7：
	 * 十进制(正数)		二进制(二进制表示)
	 * 0				0000
	 * 1				0001
	 * 2				0010
	 * 3				0011
	 * 4				0100
	 * 5				0101
	 * 6				0110
	 * 7				0111
	 *
	 * 那么 -1 ~ -7 该怎么表示呢？
	 * 
	 * 为了在计算机中表示正负数，在进制中引入了原码：
	 * 十进制(负数)		二进制(原码)
	 * -0				1000
	 * -2				1001
	 * -2				1010
	 * -3				1011
	 * -4				1100
	 * -5				1101
	 * -6				1110
	 * -7				1111
	 *
	 * 是的，把左边第一位腾出位置，存放符号，负用1来表示。
	 *
	 * 但使用“原码”储存的方式，方便了看的人类，却苦了计算机
	 * 
	 * 十进制 			二进制
	 * 1				0001
	 *
	 * 十进制			二进制
	 * -1				1001
	 *
	 * 我们希望 (+1) + (-1) = 0，但是计算机只能算出 0001 + 1001(原码) = 1010(原码)，十进制结果为 -2
	 *
	 * 另外，这里还有一个问题，+0 和 -0
	 *
	 * 为了解决“(+1) + (-1) != 0”的问题，在“原码”的基础上，人们发明了“反码”
	 *
	 * “反码”的表示方式是用来处理负数的，符号位置不变，其余位置相反。
	 * 注：符号位为最高位
	 * 
	 * 十进制(负数)		二进制(原码)	二进制(反码)
	 * -0				1000			1111
	 * -2				1001			1110
	 * -2				1010			1101
	 * -3				1011			1100
	 * -4				1100			1011
	 * -5				1101			1010
	 * -6				1110			1001
	 * -7				1111			1000
	 *
	 * 当“原码”转换为“反码”的时候，就完美的解决了“(+1) + (-1) != 0”的问题
	 *
	 * 过去的 0001 + 1001(原码) = 1010(-2)，变成了 0001 + 1110(反码) = 1111(反码)，刚好反码1111的补码表示形式十进制结果为0
	 *
	 * 人们总是进益求精，历史遗留下来的问题——有两个零存在，+0 和 -0
	 * 
	 * 我们希望只有一个0，所以在“反码”的基础上发明了"补码"，同样是针对“负数”做处理的
	 *
	 * “补码”的表现形式为：从“反码”的表现形式基础上，补上一个新的代码，也就是 “反码” + 1
	 * 
	 * 十进制(负数)		二进制(原码)	二进制(反码)	二进制(补码)
	 * -0				1000			1111			0000
	 * -2				1001			1110			1111
	 * -2				1010			1101			1110
	 * -3				1011			1100			1101
	 * -4				1100			1011			1110
	 * -5				1101			1010			1100
	 * -6				1110			1001			1010
	 * -7				1111			1000			1001
	 * -8												1000
	 *
	 * 有得必有失，在补一位(+1)的时候，要丢掉最高位。
	 *
	 * “反码” 1111，补上一位(+1)之后，变成了10000，丢掉最高位，就为0000
	 *
	 * 这样就解决了+0和-0同时存在的问题
	 *
	 * 另外“(+1) + (-1) != 0”的问题，同样得到满足
	 *
	 * 举例：(+6)和(-6)相加，0110 + 1010 = 10000，丢掉最高位，就是0000
	 *
	 * “补码”的负数相加，结果也是正确的，举例：
	 *  11101000(补码)	  -24
	 * +10011000(补码)	+-104
	 * ———————————————— ————————
	 * 110000000(补码)	 -128
	 * “补码”110000000，丢掉最高位为10000000(1000-0000)，十进制结果128，刚丢掉的最高位为符号位，所以“补码”110000000，为-128
	 *
	 * 此外，-8的“补码”表示形式可能会有人产生疑惑，我们手动转换下
	 * 十进制8，二进制表现形式为1000
	 * 二进制1000，原码表示11000(0001-1000)
	 * 原码11000，反码表示10111(1111-0111)
	 * 反码10111，补码表示101000(1110-1000)
	 *
	 *
	 * 在计算机系统中，数值一律用补码来表示和存储。
	 * 原因在于，使用补码，可以将符号位和数值域统一处理; 同时，加法和减法也可以统一处理。
	 * 此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。
	 * 
	 * 保存正负数，不断改进方案后，选择了最好的"补码"方案
	 * 
	 *
	 * 参考：
	 * https://www.zhihu.com/question/20159860/answer/71256667
	 * https://www.zhihu.com/question/20830886/answer/48079392
	 * https://www.zhihu.com/question/20458542/answer/40759880
	 * 
	 */
	
	/**
	 * 正数的原码、反码、补码相同；
	 * 负数的原码：其绝对值的原码，最高位前加一位作为符号位；
	 * 负数的反码：其符合位保持不变，其余位取反；
	 * 负数的补码：其反码+1；
	 * 负数的二进制表示，就是补码；负数的补码形式（二进制补码表示）转换为十进制数，就是补码-1，再取反，为负数的绝对值二进制表示形式。
	 * 
	 */
	
	/**
	 * 取模运算符(%)
	 * 
	 * a÷b=c……d
	 * 
	 * 则a/b=c, a%b=d 
	 * 
	 */

	/**
	 * 十进制数转二进制
	 * @param  dec 十进制数
	 * @return 二进制表示形式
	 */
	public static String toBin(int dec) {

	}

	/**
	 * System Test
	 * @param args init args
	 */
	public static void main(String[] args) {

		// Test toBin
		System.out.println("[toBin] Dec +0 		to Bin is: " + toBin(0));		// 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000
		System.out.println("[toBin] Dec +1 		to Bin is: " + toBin(1));		// 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0000-0001
		System.out.println("[toBin] Dec +1010 	to Bin is: " + toBin(1010));	// 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0000-0011 1111-0010
		System.out.println("[toBin] Dec +65535 	to Bin is: " + toBin(65535));	// 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 1111-1111 1111-1111
		System.out.println("[toBin] Dec -0 		to Bin is: " + toBin(-0));		// 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000
		System.out.println("[toBin] Dec -1 		to Bin is: " + toBin(-1));		// 1111-1111 1111-1111 1111-1111 1111-1111 1111-1111 1111-1111 1111-1111 1111-1111
		System.out.println("[toBin] Dec -1010 	to Bin is: " + toBin(-1010));	// 1111-1111 1111-1111 1111-1111 1111-1111 1111-1111 1111-1111 1111-1100 0000-1110
		System.out.println("[toBin] Dec -65535 	to Bin is: " + toBin(-65535));	// 1111-1111 1111-1111 1111-1111 1111-1111 1111-1111 1111-1111 0000-0000 0000-0001

		/**
		 * 
		 */

	}

}